/* -*-c-*-
 THIS FILE WAS AUTOGENERATED BY tool/compile_prelude.rb. DO NOT EDIT.

 sources: prelude, enc/prelude, gem_prelude, lib/rubygems/defaults, lib/rubygems/custom_require
*/
#include "ruby/ruby.h"
#include "vm_core.h"


static const char prelude_name0[] = "<internal:prelude>";
static const char prelude_code0[] =
"class Mutex\n"
"  # call-seq:\n"
"  #    mutex.synchronize { ... }\n"
"  #\n"
"  # Obtains a lock, runs the block, and releases the lock when the\n"
"  # block completes.  See the example under Mutex.\n"
"  def synchronize\n"
"    self.lock\n"
"    begin\n"
"      yield\n"
"    ensure\n"
"      self.unlock rescue nil\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"class Thread\n"
"  MUTEX_FOR_THREAD_EXCLUSIVE = Mutex.new # :nodoc:\n"
"\n"
"  # call-seq:\n"
"  #    Thread.exclusive { block }   => obj\n"
"  #  \n"
"  # Wraps a block in Thread.critical, restoring the original value\n"
"  # upon exit from the critical section, and returns the value of the\n"
"  # block.\n"
"  def self.exclusive\n"
"    MUTEX_FOR_THREAD_EXCLUSIVE.synchronize{\n"
"      yield\n"
"    }\n"
"  end\n"
"end\n"
;

static const char prelude_name1[] = "<internal:enc/prelude>";
static const char prelude_code1[] =
"%w'enc/encdb.so enc/trans/transdb.so'.each do |init|\n"
"  begin\n"
"    require(init)\n"
"  rescue LoadError\n"
"  end\n"
"end\n"
;

static const char prelude_name2[] = "<internal:gem_prelude>";
static const char prelude_code2[] =
"# depends on: array.rb dir.rb env.rb file.rb hash.rb module.rb regexp.rb\n"
"# vim: filetype=ruby\n"
"\n"
"# NOTICE: Ruby is during initialization here.\n"
"# * Encoding.default_external does not reflects -E.\n"
"# * Should not expect Encoding.default_internal.\n"
"# * Locale encoding is available.\n"
"\n"
"if defined?(Gem) then\n"
"\n"
"  # :stopdoc:\n"
"\n"
"  module Kernel\n"
"\n"
"    def gem(gem_name, *version_requirements)\n"
"      Gem::QuickLoader.load_full_rubygems_library\n"
"      gem gem_name, *version_requirements\n"
"    end\n"
"    private :gem\n"
"  end\n"
"\n"
"  module Gem\n"
"\n"
"    ConfigMap = {\n"
"      :EXEEXT            => \"\",\n"
"      :RUBY_SO_NAME      => \"ruby\",\n"
"      :arch              => \"i686-linux\",\n"
"      :bindir            => \"#{TMP_RUBY_PREFIX}/bin\",\n"
"      :libdir            => \"#{TMP_RUBY_PREFIX}/lib\",\n"
"      :ruby_install_name => \"ruby\",\n"
"      :ruby_version      => \"1.9.1\",\n"
"      :rubylibprefix     => \"#{TMP_RUBY_PREFIX}/lib/ruby\",\n"
"      :sitedir           => \"#{TMP_RUBY_PREFIX}/lib/ruby/site_ruby\",\n"
"      :sitelibdir        => \"#{TMP_RUBY_PREFIX}/lib/ruby/site_ruby/1.9.1\",\n"
"    }\n"
"\n"
"    def self.dir\n"
"      @gem_home ||= nil\n"
"      set_home(ENV['GEM_HOME'] || default_dir) unless @gem_home\n"
"      @gem_home\n"
"    end\n"
"\n"
"    def self.path\n"
"      @gem_path ||= nil\n"
"      unless @gem_path\n"
"        paths = [ENV['GEM_PATH'] || default_path]\n"
"        paths << APPLE_GEM_HOME if defined? APPLE_GEM_HOME\n"
"        set_paths(paths.compact.join(File::PATH_SEPARATOR))\n"
"      end\n"
"      @gem_path\n"
"    end\n"
"\n"
"    def self.post_install(&hook)\n"
"      @post_install_hooks << hook\n"
"    end\n"
"\n"
"    def self.post_uninstall(&hook)\n"
"      @post_uninstall_hooks << hook\n"
"    end\n"
"\n"
"    def self.pre_install(&hook)\n"
"      @pre_install_hooks << hook\n"
"    end\n"
"\n"
"    def self.pre_uninstall(&hook)\n"
"      @pre_uninstall_hooks << hook\n"
"    end\n"
"\n"
"    def self.set_home(home)\n"
"      home = home.dup.force_encoding(Encoding.find('filesystem'))\n"
"      home.gsub!(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n"
"      @gem_home = home\n"
"    end\n"
"\n"
"    def self.set_paths(gpaths)\n"
"      if gpaths\n"
"        @gem_path = gpaths.split(File::PATH_SEPARATOR)\n"
"\n"
"        if File::ALT_SEPARATOR then\n"
"          @gem_path.map! do |path|\n"
"            path.gsub File::ALT_SEPARATOR, File::SEPARATOR\n"
"          end\n"
"        end\n"
"\n"
"        @gem_path << Gem.dir\n"
"      else\n"
"        # TODO: should this be Gem.default_path instead?\n"
"        @gem_path = [Gem.dir]\n"
"      end\n"
"\n"
"      @gem_path.uniq!\n"
"      @gem_path.map!{|x|x.force_encoding(Encoding.find('filesystem'))}\n"
"    end\n"
"\n"
"    def self.user_home\n"
"      @user_home ||= File.expand_path(\"~\").force_encoding(Encoding.find('filesystem'))\n"
"    rescue\n"
"      if File::ALT_SEPARATOR then\n"
"        \"C:/\"\n"
"      else\n"
"        \"/\"\n"
"      end\n"
"    end\n"
"\n"
"    # begin rubygems/defaults\n"
"    # NOTE: this require will be replaced with in-place eval before compilation.\n"
"    TMP_RUBY_PREFIX.require(3)\n"
"    # end rubygems/defaults\n"
"\n"
"\n"
"    ##\n"
"    # Methods before this line will be removed when QuickLoader is replaced\n"
"    # with the real RubyGems\n"
"\n"
"    GEM_PRELUDE_METHODS = Gem.methods(false)\n"
"\n"
"    begin\n"
"      verbose, debug = $VERBOSE, $DEBUG\n"
"      $VERBOSE = $DEBUG = nil\n"
"\n"
"      begin\n"
"        require 'rubygems/defaults/operating_system'\n"
"      rescue ::LoadError\n"
"      end\n"
"\n"
"      if defined?(RUBY_ENGINE) then\n"
"        begin\n"
"          require \"rubygems/defaults/#{RUBY_ENGINE}\"\n"
"        rescue ::LoadError\n"
"        end\n"
"      end\n"
"    ensure\n"
"      $VERBOSE, $DEBUG = verbose, debug\n"
"    end\n"
"\n"
"    module QuickLoader\n"
"\n"
"      @loaded_full_rubygems_library = false\n"
"\n"
"      def self.remove\n"
"        return if @loaded_full_rubygems_library\n"
"\n"
"        @loaded_full_rubygems_library = true\n"
"\n"
"        class << Gem\n"
"          undef_method(*Gem::GEM_PRELUDE_METHODS)\n"
"        end\n"
"\n"
"        remove_method :const_missing\n"
"        remove_method :method_missing\n"
"\n"
"        Kernel.module_eval do\n"
"          undef_method :gem if method_defined? :gem\n"
"        end\n"
"      end\n"
"\n"
"      def self.load_full_rubygems_library\n"
"        return false if @loaded_full_rubygems_library\n"
"\n"
"        remove\n"
"\n"
"        $\".delete path_to_full_rubygems_library\n"
"        if $\".any? {|path| path.end_with?('/rubygems.rb')}\n"
"          raise LoadError, \"another rubygems is already loaded from #{path}\"\n"
"        end\n"
"\n"
"        require 'rubygems'\n"
"\n"
"        return true\n"
"      end\n"
"\n"
"      def self.path_to_full_rubygems_library\n"
"        installed_path = File.join(Gem::ConfigMap[:rubylibprefix], Gem::ConfigMap[:ruby_version])\n"
"        if $:.include?(installed_path)\n"
"          return File.join(installed_path, 'rubygems.rb')\n"
"        else # e.g., on test-all\n"
"          $:.each do |dir|\n"
"            if File.exist?( path = File.join(dir, 'rubygems.rb') )\n"
"              return path\n"
"            end\n"
"          end\n"
"          raise LoadError, 'rubygems.rb'\n"
"        end\n"
"      end\n"
"\n"
"      def const_missing(constant)\n"
"        QuickLoader.load_full_rubygems_library\n"
"\n"
"        if Gem.const_defined?(constant) then\n"
"          Gem.const_get constant\n"
"        else\n"
"          super\n"
"        end\n"
"      end\n"
"\n"
"      def method_missing(method, *args, &block)\n"
"        QuickLoader.load_full_rubygems_library\n"
"        super unless Gem.respond_to?(method)\n"
"        Gem.send(method, *args, &block)\n"
"      end\n"
"    end\n"
"\n"
"    extend QuickLoader\n"
"\n"
"    def self.try_activate(path)\n"
"      # This method is only hit when the custom require is hit the first time.\n"
"      # So we go off and dutifully load all of rubygems and retry the call\n"
"      # to Gem.try_activate. We retry because full rubygems replaces this\n"
"      # method with one that actually tries to find a gem for +path+ and load it.\n"
"      #\n"
"      # This is conditional because in the course of loading rubygems, the custom\n"
"      # require will call back into here before all of rubygems is loaded. So\n"
"      # we must not always retry the call. We only redo the call when\n"
"      # load_full_rubygems_library returns true, which it only does the first\n"
"      # time it's called.\n"
"      #\n"
"      if QuickLoader.load_full_rubygems_library\n"
"        return Gem.try_activate(path)\n"
"      end\n"
"\n"
"      return false\n"
"    end\n"
"\n"
"  end\n"
"\n"
"  begin\n"
"    TMP_RUBY_PREFIX.require(4)\n"
"  rescue Exception => e\n"
"    puts \"Error loading gem paths on load path in gem_prelude\"\n"
"    puts e\n"
"    puts e.backtrace.join(\"\\n\")\n"
"  end\n"
"\n"
"end\n"
"\n"
;

static const char prelude_name3[] = "<internal:lib/rubygems/defaults>";
static const char prelude_code3[] =
"module Gem\n"
"\n"
"  @post_install_hooks   ||= []\n"
"  @post_uninstall_hooks ||= []\n"
"  @pre_uninstall_hooks  ||= []\n"
"  @pre_install_hooks    ||= []\n"
"\n"
"  ##\n"
"  # An Array of the default sources that come with RubyGems\n"
"\n"
"  def self.default_sources\n"
"    %w[http://rubygems.org/]\n"
"  end\n"
"\n"
"  ##\n"
"  # Default home directory path to be used if an alternate value is not\n"
"  # specified in the environment\n"
"\n"
"  def self.default_dir\n"
"    if defined? RUBY_FRAMEWORK_VERSION then\n"
"      File.join File.dirname(ConfigMap[:sitedir]), 'Gems',\n"
"                ConfigMap[:ruby_version]\n"
"    elsif ConfigMap[:rubylibprefix] then\n"
"      File.join(ConfigMap[:rubylibprefix], 'gems',\n"
"                ConfigMap[:ruby_version])\n"
"    else\n"
"      File.join(ConfigMap[:libdir], ruby_engine, 'gems',\n"
"                ConfigMap[:ruby_version])\n"
"    end\n"
"  end\n"
"\n"
"  ##\n"
"  # Path for gems in the user's home directory\n"
"\n"
"  def self.user_dir\n"
"    File.join Gem.user_home, '.gem', ruby_engine, ConfigMap[:ruby_version]\n"
"  end\n"
"\n"
"  ##\n"
"  # Default gem load path\n"
"\n"
"  def self.default_path\n"
"    if File.exist? Gem.user_home then\n"
"      [user_dir, default_dir]\n"
"    else\n"
"      [default_dir]\n"
"    end\n"
"  end\n"
"\n"
"  ##\n"
"  # Deduce Ruby's --program-prefix and --program-suffix from its install name\n"
"\n"
"  def self.default_exec_format\n"
"    exec_format = ConfigMap[:ruby_install_name].sub('ruby', '%s') rescue '%s'\n"
"\n"
"    unless exec_format =~ /%s/ then\n"
"      raise Gem::Exception,\n"
"        \"[BUG] invalid exec_format #{exec_format.inspect}, no %s\"\n"
"    end\n"
"\n"
"    exec_format\n"
"  end\n"
"\n"
"  ##\n"
"  # The default directory for binaries\n"
"\n"
"  def self.default_bindir\n"
"    if defined? RUBY_FRAMEWORK_VERSION then # mac framework support\n"
"      '/usr/bin'\n"
"    else # generic install\n"
"      ConfigMap[:bindir]\n"
"    end\n"
"  end\n"
"\n"
"  ##\n"
"  # The default system-wide source info cache directory\n"
"\n"
"  def self.default_system_source_cache_dir\n"
"    File.join Gem.dir, 'source_cache'\n"
"  end\n"
"\n"
"  ##\n"
"  # The default user-specific source info cache directory\n"
"\n"
"  def self.default_user_source_cache_dir\n"
"    File.join Gem.user_home, '.gem', 'source_cache'\n"
"  end\n"
"\n"
"  ##\n"
"  # A wrapper around RUBY_ENGINE const that may not be defined\n"
"\n"
"  def self.ruby_engine\n"
"    if defined? RUBY_ENGINE then\n"
"      RUBY_ENGINE\n"
"    else\n"
"      'ruby'\n"
"    end\n"
"  end\n"
"\n"
"end\n"
"\n"
;

static const char prelude_name4[] = "<internal:lib/rubygems/custom_require>";
static const char prelude_code4[] =
"#--\n"
"# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n"
"# All rights reserved.\n"
"# See LICENSE.txt for permissions.\n"
"#++\n"
"\n"
"module Kernel\n"
"\n"
"  ##\n"
"  # The Kernel#require from before RubyGems was loaded.\n"
"\n"
"  alias gem_original_require require\n"
"\n"
"  ##\n"
"  # When RubyGems is required, Kernel#require is replaced with our own which\n"
"  # is capable of loading gems on demand.\n"
"  #\n"
"  # When you call <tt>require 'x'</tt>, this is what happens:\n"
"  # * If the file can be loaded from the existing Ruby loadpath, it\n"
"  #   is.\n"
"  # * Otherwise, installed gems are searched for a file that matches.\n"
"  #   If it's found in gem 'y', that gem is activated (added to the\n"
"  #   loadpath).\n"
"  #\n"
"  # The normal <tt>require</tt> functionality of returning false if\n"
"  # that file has already been loaded is preserved.\n"
"\n"
"  def require(path) # :doc:\n"
"    gem_original_require path\n"
"  rescue LoadError => load_error\n"
"    if load_error.message.end_with?(path)\n"
"      if Gem.try_activate(path)\n"
"        return gem_original_require(path)\n"
"      end\n"
"    end\n"
"\n"
"    raise load_error\n"
"  end\n"
"\n"
"  private :require\n"
"  private :gem_original_require\n"
"\n"
"end unless Kernel.private_method_defined?(:gem_original_require)\n"
"\n"
;

#define PRELUDE_COUNT 5

struct prelude_env {
    volatile VALUE prefix_path;
#if PRELUDE_COUNT > 0
    char loaded[PRELUDE_COUNT];
#endif
};

static VALUE
prelude_prefix_path(VALUE self)
{
    struct prelude_env *ptr = DATA_PTR(self);
    return ptr->prefix_path;
}

VALUE rb_iseq_compile_with_option(VALUE src, VALUE file, VALUE filepath, VALUE line, VALUE opt);

static void
prelude_eval(VALUE code, VALUE name, VALUE line)
{
    rb_iseq_eval(rb_iseq_compile_with_option(code, name, Qnil, line, Qtrue));
}

static VALUE
prelude_require(VALUE self, VALUE nth)
{
    struct prelude_env *ptr = DATA_PTR(self);
    VALUE code, name;
    int n = FIX2INT(nth);

    if (n > PRELUDE_COUNT) return Qfalse;
    if (ptr->loaded[n]) return Qfalse;
    ptr->loaded[n] = 1;
    switch (n) {
      case 3:
	code = rb_usascii_str_new(prelude_code3, sizeof(prelude_code3) - 1);
        name = rb_usascii_str_new(prelude_name3, sizeof(prelude_name3) - 1);
	break;
      case 4:
	code = rb_usascii_str_new(prelude_code4, sizeof(prelude_code4) - 1);
        name = rb_usascii_str_new(prelude_name4, sizeof(prelude_name4) - 1);
	break;
      default:
	return Qfalse;
    }
    prelude_eval(code, name, INT2FIX(1));
    return Qtrue;
}

void
Init_prelude(void)
{
    struct prelude_env memo;
    ID name = rb_intern("TMP_RUBY_PREFIX");
    VALUE prelude = Data_Wrap_Struct(rb_cData, 0, 0, &memo);

    memo.prefix_path = rb_const_remove(rb_cObject, name);
    rb_const_set(rb_cObject, name, prelude);
    rb_define_singleton_method(prelude, "to_s", prelude_prefix_path, 0);
    memset(memo.loaded, 0, sizeof(memo.loaded));
    rb_define_singleton_method(prelude, "require", prelude_require, 1);
    prelude_eval(
      rb_usascii_str_new(prelude_code0, sizeof(prelude_code0) - 1),
      rb_usascii_str_new(prelude_name0, sizeof(prelude_name0) - 1),
      INT2FIX(1));
    prelude_eval(
      rb_usascii_str_new(prelude_code1, sizeof(prelude_code1) - 1),
      rb_usascii_str_new(prelude_name1, sizeof(prelude_name1) - 1),
      INT2FIX(1));
    prelude_eval(
      rb_usascii_str_new(prelude_code2, sizeof(prelude_code2) - 1),
      rb_usascii_str_new(prelude_name2, sizeof(prelude_name2) - 1),
      INT2FIX(1));
    rb_gc_force_recycle(prelude);

#if 0
    puts(prelude_code0);
    puts(prelude_code1);
    puts(prelude_code2);
    puts(prelude_code3);
    puts(prelude_code4);
#endif
}
